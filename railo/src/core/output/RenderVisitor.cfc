import craft.core.content.Composite;
import craft.core.content.Container;
import craft.core.content.DocumentFoundation;
import craft.core.content.Leaf;
import craft.core.content.Placeholder;
import craft.core.content.Section;
import craft.core.content.Template;
import craft.core.content.Visitor;

import craft.core.request.Context;

component implements="Visitor" accessors="true" {

	property String content setter="false";

	public void function init(required Renderer renderer, required Context context) {

		variables.renderer = arguments.renderer
		variables.context = arguments.context
		variables.requestMethod = variables.context.getRequestMethod()

		// Define state. The following state variables will be modified during node traversal.
		// The contentType will contain the content type that the parent can render for the request content type. This will be the request content type itself, or a fallback content type.
		variables.contentType = variables.context.getContentType()
		// The model of the parent is available to every child.
		variables.parentModel = {}
		// The sections in DocumentFoundation instances are kept, so that Placeholder instances can pick them up.
		variables.sections = {}
		// Generated content. At the end of the process, this variable contains the request content.
		variables.content = ""
		// Content generated by child nodes. This content is converted to the appropriate content type.
		variables.contents = []

	}

	public void function visitTemplate(required Template template) {
		arguments.template.getSection().accept(this)
	}

	public void function visitDocument(required DocumentFoundation document) {

		// Pick up the sections / placeholders that this document is filling.
		variables.sections.append(arguments.document.getSections())

		arguments.document.getTemplate().accept(this)
	}

	public void function visitLeaf(required Leaf leaf) {

		var model = arguments.leaf.model(variables.context, variables.parentModel)
		// Append the parent model on the current model without overwriting. This effectively makes all variables of ancestor nodes available.
		model.append(variables.parentModel, false)
		var view = arguments.leaf.view(variables.context)

		var content = variables.renderer.render(view, model, variables.requestMethod, variables.contentType)
		variables.contents.append(content)
	}

	public void function visitComposite(required Composite composite) {

		// Copy state in local variables.
		var parentModel = variables.parentModel
		var contentType = variables.contentType
		var contents = variables.contents

		var model = arguments.composite.model(variables.context, variables.parentModel)
		model.append(variables.parentModel, false)
		var view = arguments.composite.view(variables.context)

		// Overwrite state.
		variables.parentModel = model
		variables.contentType = variables.renderer.contentType(view, variables.requestMethod, variables.contentType)
		variables.contents = []

		arguments.composite.traverse(this)

		// Put the content on the model so the view can include it.
		model.__content__ = variables.contentType.convert(variables.contents)

		var content = variables.renderer.render(view, model, variables.requestMethod, variables.contentType)

		// Revert state.
		variables.contents = contents
		variables.contentType = contentType
		variables.parentModel = parentModel

		variables.contents.append(content)

	}

	public void function visitContainer(required Container container) {

		var contents = variables.contents
		variables.contents = []

		var collection = variables.parentModel[arguments.container.getCollectionName()]
		var itemName = arguments.container.getItemName()

		// Visit every child once for every item in the collection.
		for (var item in collection) {
			/*
				Make the current item available on the parent model. The child doesn't know it's within the container, so the item name
				has to be the one that's expected by the child.
				The parent model is appended to the child's model later, so that makes the item available.
			*/
			variables.parentModel[itemName] = item
			arguments.container.traverse(this)
		}

		// Remove the item name from the model.
		variables.parentModel.delete(itemName)

		var content = variables.contentType.convert(variables.contents)

		// Revert state.
		variables.contents = contents
		variables.contents.append(content)

	}

	public void function visitPlaceholder(required Placeholder placeholder) {

		// The placeholder is filled if its ref exists as a key in the sections struct.
		var ref = arguments.placeholder.getRef()

		if (variables.sections.keyExists(ref)) {
			variables.sections[ref].accept(this)
		}

	}

	public void function visitSection(required Section section) {

		/*
			A section has no view, so we can keep the current content type.
			It also creates no model, so we can keep the current parent model too.
			This doesn't apply to the contents array. If the section fills a placeholder,
			the section effectively has a parent.
		*/

		var contents = variables.contents
		variables.contents = []

		arguments.section.traverse(this)

		// Write to variables.content, since any section could be the topmost one.
		variables.content = variables.contentType.convert(variables.contents)

		// Revert state.
		variables.contents = contents
		variables.contents.append(variables.content)

	}

}