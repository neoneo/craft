import craft.core.content.Composite;
import craft.core.content.Container;
import craft.core.content.DocumentFoundation;
import craft.core.content.Leaf;
import craft.core.content.Placeholder;
import craft.core.content.Section;
import craft.core.content.Template;
import craft.core.content.Visitor;

import craft.core.request.Context;

component implements="Visitor" accessors="true" {

	property String content setter="false";

	public void function init(required Renderer renderer, required Context context) {

		variables.renderer = arguments.renderer
		variables.context = arguments.context
		variables.requestMethod = variables.context.getRequestMethod()

		// Define state. The following state variables will be modified during node traversal.
		// The contentType will contain the content type that the parent can render for the request content type. This will be the request content type itself, or a fallback content type.
		variables.contentType = variables.context.getContentType()
		// The combined model of all ancestors is available to every child.
		variables.model = {}
		// The sections in DocumentFoundation instances are kept, so that Placeholder instances can pick them up.
		variables.sections = {}
		// Generated content. At the end of the process, this variable contains the request content.
		variables.content = ""
		// Content generated by child nodes. This content is converted to the appropriate content type.
		variables.contents = []

	}

	public void function visitTemplate(required Template template) {
		arguments.template.getSection().accept(this)
	}

	public void function visitDocument(required Document document) {

		// Pick up the sections / placeholders that this document is filling.
		variables.sections.append(arguments.document.getSections())

		arguments.document.getTemplate().accept(this)
	}

	public void function visitLeaf(required Leaf leaf) {

		var currentModel = arguments.leaf.model(variables.context, variables.model)
		// Append the model on the current model without overwriting. This effectively makes all variables of ancestor nodes available.
		currentModel.append(variables.model, false)
		var view = arguments.leaf.view(variables.context)

		variables.content = variables.renderer.render(view, currentModel, variables.requestMethod, variables.contentType)
		variables.contents.append(variables.content)

	}

	public void function visitComposite(required Composite composite) {

		// Copy state in local variables.
		var model = variables.model
		var contentType = variables.contentType
		var contents = variables.contents

		var currentModel = arguments.composite.model(variables.context, variables.model)
		currentModel.append(variables.model, false)
		var view = arguments.composite.view(variables.context)

		// Overwrite state.
		variables.model = currentModel
		variables.contentType = variables.renderer.contentType(view, variables.requestMethod, variables.contentType)
		variables.contents = []

		arguments.composite.traverse(this)

		// Put the content on the model so the view can include it.
		currentModel.__content__ = variables.contentType.convert(variables.contents)

		variables.content = variables.renderer.render(view, currentModel, variables.requestMethod, variables.contentType)

		// Revert state.
		variables.contents = contents
		variables.contentType = contentType
		variables.model = model

		variables.contents.append(variables.content)

	}

	// public void function visitContainer(required Container container) {

	// 	var contents = variables.contents
	// 	variables.contents = []

	// 	var collection = variables.model.__collection__

	// 	// Visit every child once for every item in the collection.
	// 	// We don't know the collection type, so use an iterator.
	// 	var iterator = collection.iterator()
	// 	while (iterator.hasNext()) {

	// 			Make the current item available on the model. The child doesn't know it's within the container, so the item name
	// 			has to be the one that's expected by the child.
	// 			The model is appended to the child's model later, so that makes the item available.

	// 		variables.model.__item__ = iterator.next()

	// 		// Use the transformer to give the child items of the proper type?
	// 		//for (var child in getChildren()) {
	// 		//	variables.model[itemName] = child.getTransformer().transform(item)
	// 		//}

	// 		arguments.container.traverse(this)
	// 	}

	// 	variables.model.delete("__item__")

	// 	var content = variables.contentType.convert(variables.contents)

	// 	// Revert state.
	// 	variables.contents = contents
	// 	variables.contents.append(content)

	// }

	public void function visitPlaceholder(required Placeholder placeholder) {

		// The placeholder is filled if its ref exists as a key in the sections struct.
		var ref = arguments.placeholder.getRef()

		if (variables.sections.keyExists(ref)) {
			variables.sections[ref].accept(this)
		}

	}

	public void function visitSection(required Section section) {

		/*
			A section has no view, so we can keep the current content type.
			It also creates no model, so we can keep the current model too.
			This doesn't apply to the contents array. If the section fills a placeholder,
			the section effectively has a parent.
		*/

		var contents = variables.contents
		variables.contents = []

		arguments.section.traverse(this)

		variables.content = variables.contentType.convert(variables.contents)

		// Revert state.
		variables.contents = contents
		variables.contents.append(variables.content)

	}

}